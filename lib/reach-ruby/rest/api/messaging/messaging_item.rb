##
#    This code was generated by
#  ___ ___   _   ___ _  _    _____ _   _    _  ___   ___      _   ___ ___      ___   _   ___     ___ ___ _  _ ___ ___    _ _____ ___  ___ 
# | _ \ __| /_\ / __| || |__|_   _/_\ | |  | |/ | \ / / |    /_\ | _ ) __|___ / _ \ /_\ |_ _|__ / __| __| \| | __| _ \  /_\_   _/ _ \| _ \
# |   / _| / _ \ (__| __ |___|| |/ _ \| |__| ' < \ V /| |__ / _ \| _ \__ \___| (_) / _ \ | |___| (_ | _|| .` | _||   / / _ \| || (_) |   /
# |_|_\___/_/ \_\___|_||_|    |_/_/ \_\____|_|\_\ |_| |____/_/ \_\___/___/    \___/_/ \_\___|   \___|___|_|\_|___|_|_\/_/ \_\_| \___/|_|_\
# 
#    Reach Messaging API
#    Reach SMS API helps you add robust messaging capabilities to your applications.  Using this REST API, you can * send SMS messages * track the delivery of sent messages * schedule SMS messages to send at a later time * retrieve and modify message history
#
#    NOTE: This class is auto generated by OpenAPI Generator.
#    https://openapi-generator.tech
#    Do not edit the class manually.
#


module Reach
    module REST
        class Api
            class Messaging < Version
                class MessagingItemList < ListResource
                    ##
                    # Initialize the MessagingItemList
                    # @param [Version] version Version that contains the resource
                    # @return [MessagingItemList] MessagingItemList
                    def initialize(version)
                        super(version)
                        # Path Solution
                        @solution = {  }
                        @uri = { 
                            "read" => "/messaging/v1/list", 
                            "dispatch" => "/messaging/v1/create"
                        }
                        
                    end
                    ##
                    # Dispatch the MessagingItemInstance
                    # @param [String] dest The destination phone number in E.164 format of the message.
                    # @param [String] src The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message.
                    # @param [String] body The text of the message to send. It can be up to 1,600 GSM-7 characters in length. That limit varies if your message is not made of only GSM-7 characters. More generally, the message body should not exceed 10 segments.
                    # @param [String] bulk_identifier The identifier of the bulk operation this message belongs to.
                    # @param [Time] scheduled_time The datetime at which the message will be sent. Must be in ISO 8601 format. A message must be scheduled at least 15 min in advance of message send time and cannot be scheduled more than 5 days in advance of the request.
                    # @param [String] status_callback The URL that will be called to send status information of your message. If provided, the API POST these message status changes to the URL: `queued`, `failed`, `sent`, `canceled`, `delivered`, or `undelivered`. URLs must contain a valid hostname and underscores are not allowed. 
                    # @param [Float] max_price The maximum total price in the applet currency that should be paid for the message to be delivered. If the cost exceeds `maxPrice`, the message will fail and a status of `failed` is sent to the status callback. 
                    # @param [String] validity_period It represents how long, in seconds, the message can remain in the queue. After this period elapses, the message fails and the status callback is called. After a message has been accepted by a carrier, however, there is no guarantee that the message will not be queued after this period. It is recommended that this value be at least 5 seconds. The maximum allowed value is 14,400 which corresponds to 4 hours. 
                    # @return [MessagingItemInstance] Dispatchd MessagingItemInstance
                    def dispatch(
                        dest: nil, 
                        src: nil, 
                        body: nil, 
                        bulk_identifier: :unset, 
                        scheduled_time: :unset, 
                        status_callback: :unset, 
                        max_price: :unset, 
                        validity_period: :unset
                    )

                        baseParams = {
                        }
                        data = Reach::Values.of(baseParams.merge({                        
                            'dest' => dest,
                            'src' => src,
                            'body' => body,
                            'bulkIdentifier' => bulk_identifier,
                            'scheduledTime' => Reach.serialize_iso8601_datetime(scheduled_time),
                            'statusCallback' => status_callback,
                            'maxPrice' => max_price,
                            'validityPeriod' => validity_period,
                        }))

                        
                        
                        payload = @version.dispatch('POST', @uri["dispatch"], data: data)
                        MessagingItemInstance.new(
                            @version,
                            payload,
                        )
                    end

                
                    ##
                    # Lists MessagingItemInstance records from the API as a list.
                    # Unlike stream(), this operation is eager and will load `limit` records into
                    # memory before returning.
                    # @param [String] dest Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
                    # @param [String] src Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
                    # @param [String] bulk_identifier Retrieve only messages that are assocaited with this `bulkIdentifier`.
                    # @param [Time] sent_at Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
                    # @param [Time] sent_after Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
                    # @param [Time] sent_before Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
                    # @param [Integer] limit Upper limit for the number of records to return. stream()
                    #    guarantees to never return more than limit.  Default is no limit
                    # @param [Integer] page_size Number of records to fetch per request, when
                    #    not set will use the default value of 50 records.  If no page_size is defined
                    #    but a limit is defined, stream() will attempt to read the limit with the most
                    #    efficient page size, i.e. min(limit, 1000)
                    # @return [Array] Array of up to limit results
                    def list(dest: :unset, src: :unset, bulk_identifier: :unset, sent_at: :unset, sent_after: :unset, sent_before: :unset, limit: nil, page_size: nil)
                        self.stream(
                            dest: dest,
                            src: src,
                            bulk_identifier: bulk_identifier,
                            sent_at: sent_at,
                            sent_after: sent_after,
                            sent_before: sent_before,
                            limit: limit,
                            page_size: page_size
                        ).entries
                    end

                    ##
                    # Streams Instance records from the API as an Enumerable.
                    # This operation lazily loads records as efficiently as possible until the limit
                    # is reached.
                    # @param [String] dest Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
                    # @param [String] src Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
                    # @param [String] bulk_identifier Retrieve only messages that are assocaited with this `bulkIdentifier`.
                    # @param [Time] sent_at Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
                    # @param [Time] sent_after Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
                    # @param [Time] sent_before Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
                    # @param [Integer] limit Upper limit for the number of records to return. stream()
                    #    guarantees to never return more than limit.  Default is no limit
                    # @param [Integer] page_size Number of records to fetch per request, when
                    #    not set will use the default value of 50 records.  If no page_size is defined
                    #    but a limit is defined, stream() will attempt to read the limit with the most
                    #    efficient page size, i.e. min(limit, 1000)
                    # @return [Enumerable] Enumerable that will yield up to limit results
                    def stream(dest: :unset, src: :unset, bulk_identifier: :unset, sent_at: :unset, sent_after: :unset, sent_before: :unset, limit: nil, page_size: nil)
                        limits = @version.read_limits(limit, page_size)

                        page = self.page(
                            dest: dest,
                            src: src,
                            bulk_identifier: bulk_identifier,
                            sent_at: sent_at,
                            sent_after: sent_after,
                            sent_before: sent_before,
                            page_size: limits[:page_size], )

                        @version.stream(page, limit: limits[:limit], page_limit: limits[:page_limit])
                    end

                    ##
                    # When passed a block, yields MessagingItemInstance records from the API.
                    # This operation lazily loads records as efficiently as possible until the limit
                    # is reached.
                    def each
                        limits = @version.read_limits

                        page = self.page(page_size: limits[:page_size], )

                        @version.stream(page,
                            limit: limits[:limit],
                            page_limit: limits[:page_limit]).each {|x| yield x}
                    end

                    ##
                    # Retrieve a single page of MessagingItemInstance records from the API.
                    # Request is executed immediately.
                    # @param [String] dest Retrieve messages sent to only this phone number. The phone number in E.164 format of the message.
                    # @param [String] src Retrieve messages sent from only this phone number, in E.164 format, or alphanumeric sender ID.
                    # @param [String] bulk_identifier Retrieve only messages that are assocaited with this `bulkIdentifier`.
                    # @param [Time] sent_at Retrieve only messages sent at the specified date. Must be in ISO 8601 format.
                    # @param [Time] sent_after Retrieve only messages sent after the specified datetime. Must be in ISO 8601 format.
                    # @param [Time] sent_before Retrieve only messages sent before the specified datetime. Must be in ISO 8601 format.
                    # @param [Integer] page_number Page Number, this value is simply for client state
                    # @param [Integer] page_size Number of records to return, defaults to 20
                    # @return [Page] Page of MessagingItemInstance
                    def page(dest: :unset, src: :unset, bulk_identifier: :unset, sent_at: :unset, sent_after: :unset, sent_before: :unset, page_token: :unset, page_number: :unset, page_size: :unset)
                        params = Reach::Values.of({
                            
                            'dest' => dest,
                            
                            'src' => src,
                            
                            'bulkIdentifier' => bulk_identifier,
                            
                            'sentAt' =>  Reach.serialize_iso8601_datetime(sent_at),
                            
                            'sentAfter' =>  Reach.serialize_iso8601_datetime(sent_after),
                            
                            'sentBefore' =>  Reach.serialize_iso8601_datetime(sent_before),
                            
                            'page' => page_number,
                            'pageSize' => page_size,
                        })

                        baseUrl = @version.url_without_pagination_info(@version.absolute_url(@uri["read"]), params)
                        response = @version.page('GET', @uri["read"], params: params)

                        MessagingItemPage.new(baseUrl, @version, response, @solution)
                    end

                    ##
                    # Retrieve a single page of MessagingItemInstance records from the API.
                    # Request is executed immediately.
                    # @param [String] target_url API-generated URL for the requested results page
                    # @return [Page] Page of MessagingItemInstance
                    def get_page(target_url)
                        baseUrl = @version.url_without_pagination_info(target_url)
                        response = @version.domain.request(
                            'GET',
                            target_url
                        )
                    MessagingItemPage.new(baseUrl, @version, response, @solution)
                    end
                    


                    # Provide a user friendly representation
                    def to_s
                        '#<Reach.Api.Messaging.MessagingItemList>'
                    end
                end


                class MessagingItemContext < InstanceContext
                    ##
                    # Initialize the MessagingItemContext
                    # @param [Version] version Version that contains the resource
                    # @param [String] message_id The identifier of the message to be updated.
                    # @return [MessagingItemContext] MessagingItemContext
                    def initialize(version, message_id)
                        super(version)

                        # Path Solution
                        @solution = { message_id: message_id,  }
                        @uri = { 
                              "fetch" => "/messaging/v1/fetch",   
                              "update" => "/messaging/v1/update",   
                              "delete" => "/messaging/v1/delete",   
                              "unschedule" => "/messaging/v1/unschedule"  
                        }

                        
                    end
                    ##
                    # Delete the MessagingItemInstance
                    # @return [Boolean] True if delete succeeds, false otherwise
                    def delete(
                    )

                        baseParams = {
                           'messageId' => @solution[:message_id],
                        }
                        
                        params = Reach::Values.of(baseParams)
                        
                        @version.delete('DELETE', @uri["delete"], data: params)
                    end

                    ##
                    # Fetch the MessagingItemInstance
                    # @return [MessagingItemInstance] Fetched MessagingItemInstance
                    def fetch(
                    )

                        baseParams = {
                           'messageId' => @solution[:message_id],
                        }
                        
                        params = Reach::Values.of(baseParams)
                        
                        payload = @version.fetch('GET', @uri["fetch"], params: params)
                        MessagingItemInstance.new(
                            @version,
                            payload,
                            message_id: @solution[:message_id],
                        )
                    end

                    ##
                    # Unschedule the MessagingItemInstance
                    # @return [MessagingItemInstance] Unscheduled MessagingItemInstance
                    def unschedule(
                    )

                        baseParams = {
                           'messageId' => @solution[:message_id],
                        }
                        
                        params = Reach::Values.of(baseParams)
                        
                        payload = @version.unschedule('POST', @uri["unschedule"], data: params)
                        MessagingItemInstance.new(
                            @version,
                            payload,
                            message_id: @solution[:message_id],
                        )
                    end

                    ##
                    # Update the MessagingItemInstance
                    # @param [String] body The text to be newly associated with the message.
                    # @return [MessagingItemInstance] Updated MessagingItemInstance
                    def update(
                        body: nil
                    )

                        baseParams = {
                           'messageId' => @solution[:message_id],
                        }
                        data = Reach::Values.of(baseParams.merge({                        
                            'body' => body,
                        }))

                        
                        
                        payload = @version.update('POST', @uri["update"], data: data)
                        MessagingItemInstance.new(
                            @version,
                            payload,
                            message_id: @solution[:message_id],
                        )
                    end


                    ##
                    # Provide a user friendly representation
                    def to_s
                        context = @solution.map{|k, v| "#{k}: #{v}"}.join(',')
                        "#<Reach.Api.Messaging.MessagingItemContext #{context}>"
                    end

                    ##
                    # Provide a detailed, user friendly representation
                    def inspect
                        context = @solution.map{|k, v| "#{k}: #{v}"}.join(',')
                        "#<Reach.Api.Messaging.MessagingItemContext #{context}>"
                    end
                end

                class MessagingItemPage < Page
                    ##
                    # Initialize the MessagingItemPage
                    # @param [String] baseUrl url without pagination info
                    # @param [Version] version Version that contains the resource
                    # @param [Response] response Response from the API
                    # @param [Hash] solution Path solution for the resource
                    # @return [MessagingItemPage] MessagingItemPage
                    def initialize(baseUrl, version, response, solution)
                        super(baseUrl, version, response)

                        # Path Solution
                        @solution = solution
                    end

                    ##
                    # Build an instance of MessagingItemInstance
                    # @param [Hash] payload Payload response from the API
                    # @return [MessagingItemInstance] MessagingItemInstance
                    def get_instance(payload)
                        MessagingItemInstance.new(@version, payload)
                    end

                    ##
                    # Provide a user friendly representation
                    def to_s
                        '<Reach.Api.Messaging.MessagingItemPage>'
                    end
                end
                class MessagingItemInstance < InstanceResource
                    ##
                    # Initialize the MessagingItemInstance
                    # @param [Version] version Version that contains the resource
                    # @param [Hash] payload payload that contains response from Reach(TalkyLabs)
                    # @param [String] account_sid The SID of the
                    #   Account that created this MessagingItem
                    #   resource.
                    # @param [String] sid The SID of the Call resource to fetch.
                    # @return [MessagingItemInstance] MessagingItemInstance
                    def initialize(version, payload , message_id: nil)
                        super(version)
                        
                        # Marshaled Properties
                        @properties = { 
                            'appletId' => payload['appletId'],
                            'apiVersion' => payload['apiVersion'],
                            'body' => payload['body'],
                            'dest' => payload['dest'],
                            'src' => payload['src'],
                            'bulkId' => payload['bulkId'],
                            'numSegments' => payload['numSegments'] == nil ? payload['numSegments'] : payload['numSegments'].to_i,
                            'numMedia' => payload['numMedia'] == nil ? payload['numMedia'] : payload['numMedia'].to_i,
                            'price' => payload['price'],
                            'priceUnit' => payload['priceUnit'],
                            'messageId' => payload['messageId'],
                            'status' => payload['status'],
                            'messageType' => payload['messageType'],
                            'errorCode' => payload['errorCode'] == nil ? payload['errorCode'] : payload['errorCode'].to_i,
                            'errorMessage' => payload['errorMessage'],
                            'dateCreated' => Reach.deserialize_iso8601_datetime(payload['dateCreated']),
                            'dateSent' => Reach.deserialize_iso8601_datetime(payload['dateSent']),
                            'dateUpdated' => Reach.deserialize_iso8601_datetime(payload['dateUpdated']),
                        }

                        # Context
                        @instance_context = nil
                        @params = { 'message_id' => message_id  || @properties['messageId']  , }
                    end

                    ##
                    # Generate an instance context for the instance, the context is capable of
                    # performing various actions.  All instance actions are proxied to the context
                    # @return [MessagingItemContext] CallContext for this CallInstance
                    def context
                        unless @instance_context
                            @instance_context = MessagingItemContext.new(@version , @params['message_id'])
                        end
                        @instance_context
                    end
                    
                    ##
                    # @return [String] The identifier of the applet sending the message.
                    def appletId
                        @properties['appletId']
                    end
                    
                    ##
                    # @return [String] The API version used to process the message.
                    def apiVersion
                        @properties['apiVersion']
                    end
                    
                    ##
                    # @return [String] The message text.
                    def body
                        @properties['body']
                    end
                    
                    ##
                    # @return [String] The phone number in E.164 format that received the message.
                    def dest
                        @properties['dest']
                    end
                    
                    ##
                    # @return [String] The phone number (in E.164 format), or the alphanumeric sender ID that initiated the message.
                    def src
                        @properties['src']
                    end
                    
                    ##
                    # @return [String] The bulk identifier allowing to group messages together and have corresponding statistics.
                    def bulkId
                        @properties['bulkId']
                    end
                    
                    ##
                    # @return [String] The number of segments associated to the message. A message body that is too large to be sent in a single SMS is segmented and charged as multiple messages. The segments are reassembled once received by the destination phone. A message can have a maximum of 10 segments. 
                    def numSegments
                        @properties['numSegments']
                    end
                    
                    ##
                    # @return [String] The number of media files included in the message
                    def numMedia
                        @properties['numMedia']
                    end
                    
                    ##
                    # @return [Float] The cost billed for the message, in the currency specified by `priceUnit`.
                    def price
                        @properties['price']
                    end
                    
                    ##
                    # @return [String] The currency, in ISO 4127 format, in which price is measured. for example, usd, xaf, eur, cad.
                    def priceUnit
                        @properties['priceUnit']
                    end
                    
                    ##
                    # @return [String] The identifier of the message
                    def messageId
                        @properties['messageId']
                    end
                    
                    ##
                    # @return [String] The status of the message. Can be: `sent`, `scheduled`, `failed`, `delivered`, `undelivered`, `canceled`, `accepted`, `queued`, `sending`, `received`, `receiving`.  
                    def status
                        @properties['status']
                    end
                    
                    ##
                    # @return [String] The type of the message. Can be: `inbound` for incoming messages, `outbound` for messages initiated by a REST API. 
                    def messageType
                        @properties['messageType']
                    end
                    
                    ##
                    # @return [String] The error code returned if the message status is `failed` or `undelivered`. The errorMessage provides more information about the failure. The value is null if the message is successful. 
                    def errorCode
                        @properties['errorCode']
                    end
                    
                    ##
                    # @return [String] The error message returned if the message status is `failed` or `undelivered`.  The value is null if the message is successful. 
                    def errorMessage
                        @properties['errorMessage']
                    end
                    
                    ##
                    # @return [Time] The date and time in GMT that the message was created. 
                    def dateCreated
                        @properties['dateCreated']
                    end
                    
                    ##
                    # @return [Time] The date and time in GMT that the message was sent. 
                    def dateSent
                        @properties['dateSent']
                    end
                    
                    ##
                    # @return [Time] The date and time in GMT that the message status was last updated. 
                    def dateUpdated
                        @properties['dateUpdated']
                    end
                    
                    ##
                    # Delete the MessagingItemInstance
                    # @return [Boolean] True if delete succeeds, false otherwise
                    def delete(
                    )

                        context.delete(
                        )
                    end

                    ##
                    # Fetch the MessagingItemInstance
                    # @return [MessagingItemInstance] Fetched MessagingItemInstance
                    def fetch(
                    )

                        context.fetch(
                        )
                    end

                    ##
                    # Unschedule the MessagingItemInstance
                    # @return [MessagingItemInstance] Unscheduled MessagingItemInstance
                    def unschedule(
                    )

                        context.unschedule(
                        )
                    end

                    ##
                    # Update the MessagingItemInstance
                    # @param [String] body The text to be newly associated with the message.
                    # @return [MessagingItemInstance] Updated MessagingItemInstance
                    def update(
                        body: nil
                    )

                        context.update(
                            body: body, 
                        )
                    end

                    ##
                    # Provide a user friendly representation
                    def to_s
                        values = @params.map{|k, v| "#{k}: #{v}"}.join(" ")
                        "<Reach.Api.Messaging.MessagingItemInstance #{values}>"
                    end

                    ##
                    # Provide a detailed, user friendly representation
                    def inspect
                        values = @properties.map{|k, v| "#{k}: #{v}"}.join(" ")
                        "<Reach.Api.Messaging.MessagingItemInstance #{values}>"
                    end
                end

            end
        end
    end
end
